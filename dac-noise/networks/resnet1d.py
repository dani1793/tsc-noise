import torch.nn as nnimport torch.nn.functional as Fimport torchfrom torch.autograd import Variableclass BasicBlock(nn.Module):    expansion = 1    def __init__(self, in_planes, planes, stride=1):        super(BasicBlock, self).__init__()        self.conv1 = nn.Conv1d(in_planes, planes, kernel_size=2, stride=stride, padding=0, bias=True)        self.bn1 = nn.BatchNorm1d(planes)        self.conv2 = nn.Conv1d(planes, planes, kernel_size=5, stride=stride, padding=0, bias=True)        self.bn2 = nn.BatchNorm1d(planes)        self.conv3 = nn.Conv1d(planes, planes, kernel_size=2, stride=stride, padding=3, bias=True)        self.bn3 = nn.BatchNorm1d(planes)        self.shortcut = nn.Sequential()        if stride != 1 or in_planes != self.expansion * planes:            self.shortcut = nn.Sequential(                nn.Conv1d(in_planes, self.expansion*planes, kernel_size=1, stride=stride, bias=True),                nn.BatchNorm1d(self.expansion*planes)            )    def forward(self, x):        #print('original x ', x.size() )        out = F.relu(self.bn1(self.conv1(x)))        #print('after block 1', out.size() )                out = F.relu(self.bn2(self.conv2(out)))        #print('after block 2', out.size() )                out = self.bn3(self.conv3(out))        #print('after block 3', out.size() )                shortcut = self.shortcut(x)        #print('shortcut', shortcut.size() )                out += shortcut         out = F.relu(out)        return outclass ResNet(nn.Module):    def __init__(self, series_length, num_classes):        super(ResNet, self).__init__()        self.inplanes = 1                self.block1 = BasicBlock(self.inplanes, 64)        self.block2 = BasicBlock(64, 128)        self.block3 = BasicBlock(128, 128)        self.linear = nn.Linear(series_length, num_classes)    def forward(self, x):        out = self.block1(x)        out = self.block2(out)        out = self.block3(out)        out = torch.mean(out, 1);        out = out.view(out.size(0), -1)        out = self.linear(out)        return outif __name__ == '__main__':    net=ResNet(8, 3)        y = net(Variable(torch.randn(128, 1, 8)))    print(y.size())